{
  "hash": "d81902dbc63fb4913855483d281a6c84",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: NumPy\n---\n\n# What is “NumPy”?\n\n> [The fundamental package for scientific computing with Python.](https://github.com/numpy/numpy)\n\n* **Num**erical **Py**thon\n* It is a package - addition features we can optional add to the Python language.\n\n## On NumPy\n\nBasically, to do scientific computing it would be nice to have:\n\n* a powerful N-dimensional array object\n* sophisticated (broadcasting) functions\n* tools for integrating C/C++ and Fortran code\n* useful linear algebra, Fourier transform, and random number capabilities\n\n(These are the stated features of NumPy.)\n\n## Relevance\n\n* We have essentially been using 1- and 2-dimensional arrays already!\n* Here is the examples `intercepts.py` solution from last time.\n  \t- It will be cut off but you can copy/paste if you need it.\n\n::: {#afeebd5e .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\ntaxes = [\n    [9275, .10],\n    [37650, .15],\n    [91150, .25],\n    [190150, .28],\n    [413350, .33],\n    [415051, .35]\n]\n\ncost = 0\nstart = 0\nfor tax in taxes:\n    cost += (tax[0] - start) * tax[1]\n    tax += [cost - tax[0] * tax[1]]\n    start = tax[0]\n```\n:::\n\n\n## We will\n\n* Change our existing _lists_, which we understand as “N-dimensional arrays” into NumPy arrays.\n* Show the benefits of this arrangement.\n* Show other NumPy features.\n\n# Package Management\n\n## PyPI\n\n> The Python Package Index (PyPI) is a repository of software for the Python programming language.\n\n* NumPy is a Python package.\n    * It is installed separately from Python, but\n    * May be installed using Python-based tools.\n\n## pip\n\n> The most popular tool for installing Python packages, and the one included with modern versions of Python.\n\n* `pip` is a command line utility\n* For years `pip` was the only real options for installing Python programs, but has experienced limitations as the package ecosystem has grown quite large.\n\n## Using `pip`\n\n* Use as an argument to `python` or `python3`\n\n```{.bash code-line-numbers=\"false\"}\npython3 -m pip install numpy\n```\n\n* It may take a moment to install.\n\n## Verify Install\n\n* The following verifies the the NumPy install was successful\n* We see the return of `import`\n    * Introduce `as`, used to shorten names\n    * We could have done `import pw as piecewise`\n\n::: {#1f758d71 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n\nprint(np.__version__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.26.4\n```\n:::\n:::\n\n\n## Aside: Dunder\n\n- Around \"version\" there are two underscores, called \"dunder\" for double underscore.\n- These \"dunder\" values are special built-in Python values with a specific meaning.\n- You can see another by just printing `np`\n\n::: {#16113d93 .cell execution_count=3}\n``` {.python .cell-code}\nprint(np)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<module 'numpy' from '/usr/lib/python3/dist-packages/numpy/__init__.py'>\n```\n:::\n:::\n\n\n## Recall\n\n* You may wish to review `import`\n* Consult [Neovim -> \\`import’](02_neovim.qmd#import)\n\n# Arrays\n\n## NumPy Arrays\n\n* The first thing to do in NumPy is make an _array_.\n* In general we use NumPy arrays when:\n    * We are dealing with lists of numbers\n    * We care about performance, or\n    * We want to use advanced mathematical operations\n\n## List to Array\n\n* We define a list of lists:\n\n::: {#62ec70d8 .cell execution_count=4}\n``` {.python .cell-code}\ntaxes = [\n    [9275, .10],\n    [37650, .15],\n    [91150, .25],\n    [190150, .28],\n    [413350, .33],\n    [415051, .35]\n]\n```\n:::\n\n\n## Lists of lists\n\n* It is worth while to examine `taxes` a bit\n\n::: {#564973ac .cell execution_count=5}\n``` {.python .cell-code}\ntaxes\n```\n\n::: {.cell-output .cell-output-display execution_count=68}\n```\n[[9275, 0.1],\n [37650, 0.15],\n [91150, 0.25],\n [190150, 0.28],\n [413350, 0.33],\n [415051, 0.35]]\n```\n:::\n:::\n\n\n## Check Types\n\n* We can verify it is a list.\n\n::: {#34f20ecf .cell execution_count=6}\n``` {.python .cell-code}\ntype(taxes)\n```\n\n::: {.cell-output .cell-output-display execution_count=69}\n```\nlist\n```\n:::\n:::\n\n\n* We can verify it’s initial element is also a list.\n\n::: {#baa216d0 .cell execution_count=7}\n``` {.python .cell-code}\ntype(taxes[0])\n```\n\n::: {.cell-output .cell-output-display execution_count=70}\n```\nlist\n```\n:::\n:::\n\n\n* Since `taxes[0]` is a list, we can look at _that_ list’s initial element.\n\n::: {#dc950cbe .cell execution_count=8}\n``` {.python .cell-code}\ntype(taxes[0][0])\n```\n\n::: {.cell-output .cell-output-display execution_count=71}\n```\nint\n```\n:::\n:::\n\n\n## Metaphor\n\n- Perhaps we regard 0-indexed element of an array as the house on the corner of a block.\n- Perhaps we regard the 0-indexed element of that \"house\" as the ground floor.\n\n::: {#3eb3a9d6 .cell execution_count=9}\n``` {.python .cell-code}\ntaxes[0][0] # House on the corner, ground floor\n```\n\n::: {.cell-output .cell-output-display execution_count=72}\n```\n9275\n```\n:::\n:::\n\n\n## Versus arrays\n\n* We have a list of lists of ints (like integers, round numbers).\n* Or do we?\n\n::: {#8130b148 .cell execution_count=10}\n``` {.python .cell-code}\ntype(taxes[0][1])\n```\n\n::: {.cell-output .cell-output-display execution_count=73}\n```\nfloat\n```\n:::\n:::\n\n\n* In fact, the tax _rates_ are not round numbers, so they are “floats”.\n* NumPy will help us manage when we use “floating point numbers” (have a decimal point) and integers (don’t).\n\n## Niceties\n\n* Each of the internal lists of numbers is of the same length.\n* That lets us do this:\n\n| Cutoff | Rate |\n| -----: | ---- |\n| 9275   | .10  |\n| 37650  | .15  |\n| 91150  | .25  |\n| 190150 | .28  |\n| 413350 | .33  |\n| 415051 | .35  |\n\n## Contingencies\n\n* This… isn’t always true.\n* In our case, for example, we have a .396 rate with _no_ cutoff.\n* We just can’t express this as an array:\n\n| Cutoff | Rate |\n| -----: | --- |\n| 413350 | .33  |\n| 415051 | .35  |\n|        | .396 |\n\n## Takeaways:\n\n* Be ready to deal with things being _almost_ arrays, but ultimately only being lists-of-lists.\n* There’s ways to deal with this (we’ve seen a few, sneakily)\n\n## Arrays\n\n> In computer programming, an array is a structure for storing and retrieving data. We often talk about an array as if it were a grid in space, with each cell storing one element of the data. For instance, if each element of the data were a number, we might visualize a “one-dimensional” array like a list:\n\n\n$$\n    \\begin{array}{|c||c|c|c|}\n    \\hline\n    9275 & 37650 & 91150 & 190150 \\\\\n    \\hline\n    \\end{array}\n$$\n\n## Tables\n\n> A two-dimensional array would be like a table:\n\n$$\n    \\begin{array}{|c||c|c|c|}\n    \\hline\n    9275 & 37650 & 91150 & 190150 \\\\\n    \\hline\n    .10 & .15 & .25 & .28 \\\\\n    \\hline\n    0 & -463.75 & -6963.25 & -16470.75 \\\\\n    \\hline\n    \\end{array}\n$$\n\n## ndarray\n\n> A three-dimensional array would be like a set of tables, perhaps stacked as though they were printed on separate pages. In NumPy, this idea is generalized to an arbitrary number of dimensions, and so the fundamental array class is called `ndarray`: it represents an “N-dimensional array”.\n\n- The most obvious 3D example would be that `taxes` part of an *array* of tax policies\n```{.python}\n[\"Single\", \"Married, joint\", \"Married, separate\", \"Head of Household\"]\n```\n\n## Metaphor\n\n- Perhaps we have blocks in a city.\n- Houses on a block.\n- Stories on a house or floors in apartment.\n\n## Making Arrays\n\n- Make an array with `np.array()`\n  \t- Or `numpy.array` if you used `import numpy`\n- They look like this:\n\n::: {#df8390d3 .cell execution_count=11}\n``` {.python .cell-code}\narr = np.array(taxes)\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=74}\n```\narray([[9.27500e+03, 1.00000e-01],\n       [3.76500e+04, 1.50000e-01],\n       [9.11500e+04, 2.50000e-01],\n       [1.90150e+05, 2.80000e-01],\n       [4.13350e+05, 3.30000e-01],\n       [4.15051e+05, 3.50000e-01]])\n```\n:::\n:::\n\n\n- Our integers are gone - everything in scientific notation\n\n## Aside: Scientific Notation\n\n> [Scientific notation is a way of expressing numbers that are too large or too small to be conveniently written in decimal form, since to do so would require writing out an inconveniently long string of digits.](https://en.wikipedia.org/wiki/Scientific_notation)\n\n- In scientific notation, nonzero numbers are written in the form \n\n$$a \\times 10^b$$\n\n## Aside: Explanation\n\n\n- In scientific notation, nonzero numbers are written in the form \n\n$$a \\times 10^b$$\n\n\n* $a$ (the coefficient or mantissa) is a number greater than or equal to 1 and less than 10 ($1 \\le |a| < 10$).\n* $10$ is the base.\n* $b$ (the exponent) is an integer.\n\n\n## Aside: Physical Examples\n\n1.  **Speed of light:** The speed of light in a vacuum is approximately $300,000,000 \\text{ m/s}$\n$$\n3 \\times 10^8 \\text{ m/s}\n$$\n\n2.  **Mass of an electron:** The mass of an electron is approximately $0.00000000000000000000000000091093837 \\text{ g}$.\n$$\n9.1093837 \\times 10^{-28} \\text{ g}\n$$\n\n## Aside: Economic Examples\n\n- We can use social science numbers.\n- [Labor Market Outcomes of College Graduates by Major](https://www.newyorkfed.org/research/college-labor-market#--:explore:outcomes-by-major)\n- Computer Science majors in 2025 have a \\$80,000 median wage\n\t- $8.0000 \\times 10^4$\n- And 6.1% unemployment\n  \t- $6.1 \\times 10^{-2}$\n\n# Using Arrays\n\n## Inspecting Arrays\n\n- Given some array, we can look up elements in an array as we did with lists.\n- We refer to zero as the \"index\" of the initial element of an array (or list).\n\n:::: {.carr[0]olumns}\n\n::: {.column width=\"50%\"}\n\n::: {#bf0d6c72 .cell execution_count=12}\n``` {.python .cell-code}\ntaxes[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=75}\n```\n[9275, 0.1]\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {#d6c4ae77 .cell execution_count=13}\n``` {.python .cell-code}\narr[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=76}\n```\narray([9.275e+03, 1.000e-01])\n```\n:::\n:::\n\n\n:::\n\n::::\n\n- We look up the same element by the same index in both Python lists and NumPy arrays.\n\n## Slices\n\n- Python and NumPy support *slicing*\n- This takes multiple elements of an array by specifying a *range* of indices\n- Let's make a one-dimensional array to make matters simpler.\n\n::: {#b584fa87 .cell execution_count=14}\n``` {.python .cell-code}\ncolors = [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"indigo\", \"violet\"]\n```\n:::\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {#99b4e8cf .cell execution_count=15}\n``` {.python .cell-code}\ncolor_lst = colors\ncolor_lst[1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=78}\n```\n['orange', 'yellow', 'green']\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {#bee26c00 .cell execution_count=16}\n``` {.python .cell-code}\ncolor_arr = np.array(colors)\ncolor_arr[1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=79}\n```\narray(['orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n:::\n\n::::\n\n- `dtype` is data type - We'll cover it soon.\n\n## Understanding slices\n\n- The slice `1:4` takes all elements at index beginning at `1` and stopping before getting to index `4`.\n\n$$\n\\small\n\\begin{array}{|c|c|c|c|c|c|}\n\\hline\n 0 & 1 & 2 & 3 & 4 & 5 & 6   \\\\\n\\hline\n red & orange& yellow& green& blue& indigo& violet\\\\\n\\hline\n\\end{array}\n$$\n\n$$\n\\small\n\\begin{array}{|c|c|c|}\n\\hline\n 1 & 2 & 3   \\\\\n\\hline\n orange& yellow& green\\\\\n\\hline\n\\end{array}\n$$\n\n## Omiting Values\n\n- If we omit the value before the `:` from the slice, it is treated as if a zero was provided.\n\n::: {#7cda8346 .cell execution_count=17}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=80}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n::: {#a0b0193c .cell execution_count=18}\n``` {.python .cell-code}\ncolor_arr[0:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=81}\n```\narray(['red', 'orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n::: {#aaf0b931 .cell execution_count=19}\n``` {.python .cell-code}\ncolor_arr[:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=82}\n```\narray(['red', 'orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n## Omiting End\n\n- If we omit the value after the `:` from the slice, it is as if the length was provided.\n\n::: {#4719823a .cell execution_count=20}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=83}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n- `len` gives the length of a list or array\n\n::: {#d2838878 .cell execution_count=21}\n``` {.python .cell-code}\nlen(color_arr)\n```\n\n::: {.cell-output .cell-output-display execution_count=84}\n```\n7\n```\n:::\n:::\n\n\n::: {#e3ade788 .cell execution_count=22}\n``` {.python .cell-code}\ncolor_arr[4:7]\n```\n\n::: {.cell-output .cell-output-display execution_count=85}\n```\narray(['blue', 'indigo', 'violet'], dtype='<U6')\n```\n:::\n:::\n\n\n::: {#5da37ceb .cell execution_count=23}\n``` {.python .cell-code}\ncolor_arr[4:]\n```\n\n::: {.cell-output .cell-output-display execution_count=86}\n```\narray(['blue', 'indigo', 'violet'], dtype='<U6')\n```\n:::\n:::\n\n\n## Steps\n \n- Python and NumPy slices have an additional feature I find quite nice called \"steps\"\n- We specify a slice:\n\n::: {#987efd66 .cell execution_count=24}\n``` {.python .cell-code}\ncolor_arr[1:4]\n```\n\n::: {.cell-output .cell-output-display execution_count=87}\n```\narray(['orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n- We add a *third* value\n\n::: {#a187a755 .cell execution_count=25}\n``` {.python .cell-code}\ncolor_arr[1:4:1]\n```\n\n::: {.cell-output .cell-output-display execution_count=88}\n```\narray(['orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n## Step Size\n\n- We add a *third* value\n\n::: {#4e5b926d .cell execution_count=26}\n``` {.python .cell-code}\ncolor_arr[1:4:1]\n```\n\n::: {.cell-output .cell-output-display execution_count=89}\n```\narray(['orange', 'yellow', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n- This value determines how far to move over the original array between each element shown.\n  - Let's look at `2` - every other element.\n\n::: {#9b82e061 .cell execution_count=27}\n``` {.python .cell-code}\ncolor_arr[1:4:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=90}\n```\narray(['orange', 'green'], dtype='<U6')\n```\n:::\n:::\n\n\n## Example\n\n- In kindergarten, I learned that red, yellow, and blue were primary colors.\n\t- Less sure now but a good ex. \n\n::: {#ca4eb2a9 .cell execution_count=28}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=91}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n- And the primaries:\n\n::: {#d9cb66ea .cell execution_count=29}\n``` {.python .cell-code}\ncolor_arr[0:5:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=92}\n```\narray(['red', 'yellow', 'blue'], dtype='<U6')\n```\n:::\n:::\n\n\n## Step Omissions\n\n- We can omit start, stop, or both and still take steps.\n\n::: {#edd9802d .cell execution_count=30}\n``` {.python .cell-code}\ncolor_arr[::3]\n```\n\n::: {.cell-output .cell-output-display execution_count=93}\n```\narray(['red', 'green', 'violet'], dtype='<U6')\n```\n:::\n:::\n\n\n- We can use a *negative* step to reverse.\n\n::: {#ca27affb .cell execution_count=31}\n``` {.python .cell-code}\ncolor_arr[::-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=94}\n```\narray(['violet', 'indigo', 'blue', 'green', 'yellow', 'orange', 'red'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n## Aside: Negatives\n\n- Negative starts and stops can also be used\n\n::: {#55f39c3f .cell execution_count=32}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=95}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n- They simply measure distance from the end.\n\n::: {#e955ea80 .cell execution_count=33}\n``` {.python .cell-code}\ncolor_arr[:-2]\n```\n\n::: {.cell-output .cell-output-display execution_count=96}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue'], dtype='<U6')\n```\n:::\n:::\n\n\n## Coordinates\n\n- Versus Python lists-of-lists.\n\n::: {#091a2848 .cell execution_count=34}\n``` {.python .cell-code}\ntaxes[1][1]\n```\n\n::: {.cell-output .cell-output-display execution_count=97}\n```\n0.15\n```\n:::\n:::\n\n\n- NumPy arrays can specify coordinates - indices of multiple dimensions - in a single set of brackets.\n\n::: {#199313b7 .cell execution_count=35}\n``` {.python .cell-code}\narr[1][1], arr[1, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=98}\n```\n(0.15, 0.15)\n```\n:::\n:::\n\n\n## Coordinate slices\n\n- I recommend using the comma notation.\n- Otherwise I get unexpected behavior.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {#4a8cdd8d .cell execution_count=36}\n``` {.python .cell-code}\n# reverse in both dimensions\narr[::-1][::-1] # Just reverses twice \n```\n\n::: {.cell-output .cell-output-display execution_count=99}\n```\narray([[9.27500e+03, 1.00000e-01],\n       [3.76500e+04, 1.50000e-01],\n       [9.11500e+04, 2.50000e-01],\n       [1.90150e+05, 2.80000e-01],\n       [4.13350e+05, 3.30000e-01],\n       [4.15051e+05, 3.50000e-01]])\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {#9d73481b .cell execution_count=37}\n``` {.python .cell-code}\n# reverse in both dimensions\narr[::-1,::-1] # It works!\n```\n\n::: {.cell-output .cell-output-display execution_count=100}\n```\narray([[3.50000e-01, 4.15051e+05],\n       [3.30000e-01, 4.13350e+05],\n       [2.80000e-01, 1.90150e+05],\n       [2.50000e-01, 9.11500e+04],\n       [1.50000e-01, 3.76500e+04],\n       [1.00000e-01, 9.27500e+03]])\n```\n:::\n:::\n\n\n:::\n\n::::\n\n- Takeaway:  Always use `[x,y]` instead of `[x][y]`\n- Things like this are we use NumPy!\n\n## Example\n\n- I want all the tax rates\n  \t- Metaphor: 1st floor of every apartment on the block.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {#26b518e9 .cell execution_count=38}\n``` {.python .cell-code}\n# Look at the whole block, take address 1\narr[:][1] # Gives house address one\n```\n\n::: {.cell-output .cell-output-display execution_count=101}\n```\narray([3.765e+04, 1.500e-01])\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {#52c7bd4e .cell execution_count=39}\n``` {.python .cell-code}\n# Look at the whole block, take address 1\narr[:, 1] # Gives all first floors on the block\n```\n\n::: {.cell-output .cell-output-display execution_count=102}\n```\narray([0.1 , 0.15, 0.25, 0.28, 0.33, 0.35])\n```\n:::\n:::\n\n\n:::\n\n::::\n\n\n## Updates\n\n- We can also update entries via `=`\n\n::: {#79d28756 .cell execution_count=40}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=103}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n-  Use (1) name of array, (2) index of element, (3) `=`, (4) new element\n\n::: {#b6974817 .cell execution_count=41}\n``` {.python .cell-code}\ncolor_arr[-1] = 'purple'\n```\n:::\n\n\n- The array now has that element/index.\n\n::: {#2f6b6abc .cell execution_count=42}\n``` {.python .cell-code}\ncolor_arr\n```\n\n::: {.cell-output .cell-output-display execution_count=105}\n```\narray(['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'purple'],\n      dtype='<U6')\n```\n:::\n:::\n\n\n# Vectorization\n\n## Why NumPy?\n\n- NumPy vectors can do a *very* cool thing that lists can't.\n- We use it a lot in science.\n- *Vector operations*.\n\n## Vector Ops\n\n- Let's compare Python\n\n::: {#d4c5bcc6 .cell execution_count=43}\n``` {.python .cell-code}\nl1 = [1,2,3]\nl2 = [1,1,1]\nl1 + l2\n```\n\n::: {.cell-output .cell-output-display execution_count=106}\n```\n[1, 2, 3, 1, 1, 1]\n```\n:::\n:::\n\n\n- To NumPy\n\n::: {#bfec3be8 .cell execution_count=44}\n``` {.python .cell-code}\na1 = np.array(l1)\na2 = np.array(l2)\na1 + a2\n```\n\n::: {.cell-output .cell-output-display execution_count=107}\n```\narray([2, 3, 4])\n```\n:::\n:::\n\n\n- By the way, vectorization is really fast.\n- Our first \"high performance computing\" idea.\n\n## Example\n\n- Suppose you need to convert some temperatures.\n\n::: {#75e7b6f0 .cell execution_count=45}\n``` {.python .cell-code}\n# Portland highs and lows 5/26/25-6/2/25 in degF\ntemps = np.array([70, 50, 81, 60, 85, 57, 70, 52, 84, 58, 87, 58, 74, 53, 70, 54])\ntemps -= 32\ntemps *= 5\ntemps //= 9\ntemps\n```\n\n::: {.cell-output .cell-output-display execution_count=108}\n```\narray([21, 10, 27, 15, 29, 13, 21, 11, 28, 14, 30, 14, 23, 11, 21, 12])\n```\n:::\n:::\n\n\n## Aside: `//`\n\n- NumPy requires arrays to be of a certain kind of number.\n- `30` is an integer.\n- `30/9` is a decimal value...\n- Python furnishes special `//` integer division.\n\t- It truncates (does not round) the result.\n\n::: {#dd64ced4 .cell execution_count=46}\n``` {.python .cell-code}\nnp.array([1,2,3,4,5,6,7,8,9,10]) // 3\n```\n\n::: {.cell-output .cell-output-display execution_count=109}\n```\narray([0, 0, 1, 1, 1, 2, 2, 2, 3, 3])\n```\n:::\n:::\n\n\n- Try using `/` there. What happens?\n\n## Use case \n\n- Slices and vectorization help with income tax.\n- We:\n  \t- Had income cutoffs, that were\n\t- The *beginning* of some tax brackets, but\n\t- The *end* of other tax brackets\n\t- Offset by one (`1`)\n\n## Building Brackets\n\n- Let's refresh on what the tax bracket array looked like.\n\n::: {#e63ec5cf .cell execution_count=47}\n``` {.python .cell-code}\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=110}\n```\narray([[9.27500e+03, 1.00000e-01],\n       [3.76500e+04, 1.50000e-01],\n       [9.11500e+04, 2.50000e-01],\n       [1.90150e+05, 2.80000e-01],\n       [4.13350e+05, 3.30000e-01],\n       [4.15051e+05, 3.50000e-01]])\n```\n:::\n:::\n\n\n- Initial tax bracket goes zero and to `9275`\n- The next goes from `9275` to `37650`.\n- So `9275` is useful to two brackets.\n\n## Begin and end\n\n- Let's grab just the cutoffs.\n\n::: {#1ae7b62b .cell execution_count=48}\n``` {.python .cell-code}\ncutoffs = arr[:,0]\ncutoffs\n```\n\n::: {.cell-output .cell-output-display execution_count=111}\n```\narray([  9275.,  37650.,  91150., 190150., 413350., 415051.])\n```\n:::\n:::\n\n\n- `[:, 0]` means for every row (slice `:`) take the initial columns (index `0`)\n\t- Take the ground floor of every house on the block.\n\n## Insert\n\n- The initial bracket begins at `0` and the last bracket ends at infinity.\n\t- NumPy knows about infinity! `np.inf`\n- We can use NumPy `insert` to add an element at an index:\n\n::: {#c4f10cb2 .cell execution_count=49}\n``` {.python .cell-code}\n# Insert to (a) an array at (b) some index (c) some value\na = cutoffs\nb = len(cutoffs)\nc = np.inf\ncutoffs = np.insert(a, b, c)\ncutoffs\n```\n\n::: {.cell-output .cell-output-display execution_count=112}\n```\narray([  9275.,  37650.,  91150., 190150., 413350., 415051.,     inf])\n```\n:::\n:::\n\n\n## Append\n\n- I usually don't insert, I append.\n- This allows adding two arrays together, like how Python `+` works on lists.\n  \t- Remember, NumPy can treat a value like `0` as a 0-D (zero dimensional) array.\n\t- `[0]` would also work.\n\n::: {#289bbd91 .cell execution_count=50}\n``` {.python .cell-code}\n# Smoosh arrays, including scalars, together.\ncutoffs = np.append(0,cutoffs)\ncutoffs\n```\n\n::: {.cell-output .cell-output-display execution_count=113}\n```\narray([     0.,   9275.,  37650.,  91150., 190150., 413350., 415051.,\n           inf])\n```\n:::\n:::\n\n\n## Slicing\n\n- Now we can take the beginning of every bracket, by index:\n\n::: {#04f97789 .cell execution_count=51}\n``` {.python .cell-code}\nbegin = cutoffs[:-1]\nbegin\n```\n\n::: {.cell-output .cell-output-display execution_count=114}\n```\narray([     0.,   9275.,  37650.,  91150., 190150., 413350., 415051.])\n```\n:::\n:::\n\n\n- And the end\n\n::: {#5147937c .cell execution_count=52}\n``` {.python .cell-code}\nend = cutoffs[1:]\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=115}\n```\narray([  9275.,  37650.,  91150., 190150., 413350., 415051.,     inf])\n```\n:::\n:::\n\n\n## Vector Minus\n\n- We can see how big each bracket is.\n\n::: {#e1a4a54a .cell execution_count=53}\n``` {.python .cell-code}\nbracket_size = end - begin\nbracket_size\n```\n\n::: {.cell-output .cell-output-display execution_count=116}\n```\narray([  9275.,  28375.,  53500.,  99000., 223200.,   1701.,     inf])\n```\n:::\n:::\n\n\n## Vector Times\n\n- We can see how much tax is spent in each bracket.\n  - We will \"cut off\" the last bracket first\n  - It doesn't really have a size?\n\n::: {#41ac538a .cell execution_count=54}\n``` {.python .cell-code}\nbracket_cost = bracket_size[:-1] * arr[:, 1]\nbracket_cost\n```\n\n::: {.cell-output .cell-output-display execution_count=117}\n```\narray([  927.5 ,  4256.25, 13375.  , 27720.  , 73656.  ,   595.35])\n```\n:::\n:::\n\n\n- What happens if we don't cut off the last bracket and try to multiply a vector of length `7` by a vector of length `6`?\n\n## Accumulation\n\n- While `bracket_cost` does correctly describe the cost within on bracket, someone in the `n+1`'th bracket pays the cost the previous `n` brackets.\n- Someone how we want to sum those up.\n- NumPy has many built-in array functions, including `np.cumsum`.\n\n::: {#c981e8eb .cell execution_count=55}\n``` {.python .cell-code}\ntotal_cost = np.cumsum(bracket_cost)\ntotal_cost\n```\n\n::: {.cell-output .cell-output-display execution_count=118}\n```\narray([   927.5 ,   5183.75,  18558.75,  46278.75, 119934.75, 120530.1 ])\n```\n:::\n:::\n\n\n## Aside: Mean\n\n- Other than `np.cumsum`, there are other functions over arrays we often use.\n- It isn't particularly useful here, but `np.mean` is quite common:\n\n::: {#148137a9 .cell execution_count=56}\n``` {.python .cell-code}\nnp.mean(total_cost)\n```\n\n::: {.cell-output .cell-output-display execution_count=119}\n```\n51902.26666666666\n```\n:::\n:::\n\n\n- Takeaway: Some functions convert arrays back to values.\n\n# Takeaways\n\n## NumPy does a lot!\n- [Arrays](https://numpy.org/doc/stable/user/basics.creation.html) mostly, but including:\n- Vector operations called [\"broadcasting\"](https://numpy.org/doc/stable/user/basics.broadcasting.html).\n- [Indices and slices](https://numpy.org/doc/stable/user/basics.indexing.html) matter a lot.\n- [Contants](https://numpy.org/devdocs/reference/constants.html) like `np.inf` support mathematics\n- [Accumulation functions](https://numpy.org/doc/2.1/reference/routines.math.html#sums-products-differences) we don't have to write ourselves (which we'd have to do via loops)\n\n## On Names{.smaller}\n\n> You might hear of a 0-D (zero-dimensional) array referred to as a “scalar”, a 1-D (one-dimensional) array as a “vector”, a 2-D (two-dimensional) array as a “matrix”, or an N-D (N-dimensional, where “N” is typically an integer greater than 2) array as a “tensor”. \n\n> For clarity, it is best to avoid the mathematical terms when referring to an array because the mathematical objects with these names behave differently than arrays (e.g. “matrix” multiplication is fundamentally different from “array” multiplication), and there are other objects in the scientific Python ecosystem that have these names (e.g. the fundamental data structure of PyTorch is the “tensor”).\n\n\n# Exercise\n\n## Using NumPy\n\n- Today we successfully recomputed the points of the point-intercept form of the income tax problem.\n- Using NumPy, starting with `taxes`, create the array on the right:\n\n:::: {.columns}\n\n::: {.column width=\"28%\"}\n\n::: {#0ac1aee7 .cell execution_count=57}\n``` {.python .cell-code}\ntaxes = np.array([\n    [9275, .1],\n    [37650, .15],\n    [91150, .25],\n    [190150, .28],\n    [413350, .33],\n    [415051, .35]\n])\n```\n:::\n\n\n:::\n\n::: {.column width=\"72%\"}\n\n::: {#4aed7005 .cell execution_count=58}\n``` {.python .cell-code}\nnp.array([[ 9.275000e+03,  1.000000e-01,  0.000000e+00],\n          [ 3.765000e+04,  1.500000e-01, -4.637500e+02],\n          [ 9.115000e+04,  2.500000e-01, -4.228750e+03],\n          [ 1.901500e+05,  2.800000e-01, -6.963250e+03],\n          [ 4.133500e+05,  3.300000e-01, -1.647075e+04],\n          [ 4.150510e+05,  3.500000e-01, -2.473775e+04]])\n```\n:::\n\n\n:::\n\n::::\n\n## Transpose\n\n- There are many ways to solve this problem!\n- Things will be easier with the following:\n\n::: {#49c9b0f7 .cell execution_count=59}\n``` {.python .cell-code}\ntaxes.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=121}\n```\n(6, 2)\n```\n:::\n:::\n\n\n::: {#a5018284 .cell execution_count=60}\n``` {.python .cell-code}\ntaxes.reshape(2,6)\n```\n\n::: {.cell-output .cell-output-display execution_count=122}\n```\narray([[9.27500e+03, 1.00000e-01, 3.76500e+04, 1.50000e-01, 9.11500e+04,\n        2.50000e-01],\n       [1.90150e+05, 2.80000e-01, 4.13350e+05, 3.30000e-01, 4.15051e+05,\n        3.50000e-01]])\n```\n:::\n:::\n\n\n::: {#38cc47f3 .cell execution_count=61}\n``` {.python .cell-code}\ntaxes.transpose()\n```\n\n::: {.cell-output .cell-output-display execution_count=123}\n```\narray([[9.27500e+03, 3.76500e+04, 9.11500e+04, 1.90150e+05, 4.13350e+05,\n        4.15051e+05],\n       [1.00000e-01, 1.50000e-01, 2.50000e-01, 2.80000e-01, 3.30000e-01,\n        3.50000e-01]])\n```\n:::\n:::\n\n\n## Bonus Problem\n\n- NumPy allows random number generation.\n- Generate one million random numbers between, say, `0` and `500000`.\n  - There will be repeats, which is okay.\n- Use Python with and without NumPy to compute every tax cost.\n- See which one is faster! You can use the shell command `time`\n\n## Aside: Random\n\n- The following:\n  - Generates 1 million random integers from `0` to `50000`\n  - Prints every 10 thousandth integer.\n\n::: {#8d453cad .cell execution_count=62}\n``` {.python .cell-code}\nimport numpy as np\nrng = np.random.default_rng()\nincomes = rng.integers(0, 500000, 1000000)\nprint(incomes[::10000])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[410907 159127 300191 307902 357960 136222 437026 109030 273268  88539\n 456241 134564 180183 325223 136434 304736 282183  29243 133058 487577\n 382562  51212 288934 133416 417353  19660 197260 453843 103815  95104\n 353337 162886 302353 430037 102243  86634  52051 482203 490478 216449\n 323657 210036 496238 243801 209375 421017 195874 397143 131358  17804\n 144604    808   3653 488675 460170 384757 441921  78862  61703 483595\n 273486 368416  88643 365887 162816 305914 413988 219777 224312 215707\n 150024 133477 325734  18837 337653 400267 412208 285869   1730 489933\n 168158 334886 441148 156624 188558 250091 141812 385544 396185 366189\n 419542 166840 489804 419570 238538  23807 414215 434035  96668 152917]\n```\n:::\n:::\n\n\n- Read more: [Random sample](https://numpy.org/doc/stable/reference/random/index.html)\n\n## Aside: `time`\n\n- Use `time` before a command.\n  - `real` time is how much passes in real life\n\n```{.bash code-line-numbers=\"false}\n$ time python3 onemil.py\n[123177 422613 471310 380518  95385 143328 426503 453832 427403 106416\n 327306 476263  65814 281381 422404  59938  14231 232824 342190 329545\n 412684 112339 202498   5071  59114 394601 451216  92268 381107 487447\n  55089 339493 344836 261917 148326 452850 409130 484951 427839 307217\n 259268 485208 331277 183015 132480 345930 439366   6814  39743 268276\n  80739 293355 170394   4220  48082  15668 453927  58059 320294 101182\n   1864 492297 130465   9920  76321 345944 268312 255875  46614 195236\n 233737 443948 343483 116870 165561 326265 103567 327780 475672 392212\n 396479 328248  43273  32596 246212   4258  60202  66783 135035 155327\n 469638 378485 175496 428130 493185 154716 193012 424037 197666 103758]\n\nreal    0m0.155s\nuser    0m1.883s\nsys     0m0.033s\n```\n\n## Solution\n\n::: {#b5672bc5 .cell execution_count=63}\n``` {.python .cell-code code-fold=\"true\"}\ncutoffs = taxes[:,0]\nrates = taxes[:,1]\n\n# If you are confused, print(arr) after every line\narr = np.append([0], cutoffs)\narr = arr[1:] - arr[:-1]\narr *= rates\narr = np.cumsum(arr)\narr = arr - cutoffs * rates\n\ntaxes = np.array([cutoffs,rates,arr])\n\ntaxes = taxes.transpose()\n```\n:::\n\n\n## Using it\n\n- I used the exact same `single_tax` function as in the \"Shell\" exercise.\n\n::: {#514fbd83 .cell execution_count=64}\n``` {.python .cell-code code-fold=\"true\"}\ndef single_tax(income):\n    # Check all brackets\n    for tax in taxes:\n        if income < tax[0]:\n            return income * tax[1] + tax[2]\n    # We calculated the top bracket earlier\n    return income * .396 + -43830.05\n```\n:::\n\n\n",
    "supporting": [
      "04_numpy_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}