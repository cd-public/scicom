{
  "hash": "9a924b45ad52166681d19fe7387a2b1b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: SymPy\n---\n\n# What is SymPy?\n\n> [A Python library for symbolic mathematics. It aims to become a full-featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible. SymPy is written entirely in Python.](https://www.sympy.org/en/index.html)\n\n* **Sym**bolic **Py**thon\n\n## Why SymPy \n\n* \"SymPy is free both as in speech and as in beer.\"\n* \"Most computer algebra systems invent their own language. Not SymPy.\"\n* \"An advantage of SymPy is that it is lightweight.\"\n\n## Why not SymPy\n\n- To my knowledge, there's no real competitors with SymPy.\n- The closest are probably SageMath and Mathematica.\n- I use browser-based Mathematica via [https://www.wolframalpha.com/](https://www.wolframalpha.com/) from time to time (when I don't have a Python installation handy).\n\n## Cite\n\n```{.bibtex}\n@article{10.7717/peerj-cs.103,\n     title = {SymPy: symbolic computing in Python},\n     author = {Meurer, Aaron and Smith, Christopher P. and Paprocki, Mateusz and \\v{C}ert\\'{i}k, Ond\\v{r}ej and Kirpichev, Sergey B. and Rocklin, Matthew and Kumar, AMiT and Ivanov, Sergiu and Moore, Jason K. and Singh, Sartaj and Rathnayake, Thilina and Vig, Sean and Granger, Brian E. and Muller, Richard P. and Bonazzi, Francesco and Gupta, Harsh and Vats, Shivam and Johansson, Fredrik and Pedregosa, Fabian and Curry, Matthew J. and Terrel, Andy R. and Rou\\v{c}ka, \\v{S}t\\v{e}p\\'{a}n and Saboo, Ashutosh and Fernando, Isuru and Kulal, Sumith and Cimrman, Robert and Scopatz, Anthony},\n     year = 2017,\n     month = jan,\n     keywords = {Python, Computer algebra system, Symbolics},\n     abstract = {\n                SymPy is an open source computer algebra system written in pure Python. It is built with a focus on extensibility and ease of use, through both interactive and programmatic applications. These characteristics have led SymPy to become a popular symbolic library for the scientific Python ecosystem. This paper presents the architecture of SymPy, a description of its features, and a discussion of select submodules. The supplementary material provide additional examples and further outline details of the architecture and features of SymPy.\n             },\n     volume = 3,\n     pages = {e103},\n     journal = {PeerJ Computer Science},\n     issn = {2376-5992},\n     url = {https://doi.org/10.7717/peerj-cs.103},\n     doi = {10.7717/peerj-cs.103}\n    }\n```\n\n\n## pip again\n\n- Just like NumPy, Matplotlib is a Python package which we install via `pip`\n```{.bash code-line-numbers=\"false\"}\npython3 -m pip install sympy\n```\n- That might take a moment, when it does we can check it worked!\n\n# Motivation \n\n## Example\n\n- Computers don't hold numbers that precisely.\n\n::: {#fa14358f .cell execution_count=2}\n``` {.python .cell-code}\n10.0 ** 100 == 10.0 ** 100 + 47\n```\n\n::: {.cell-output .cell-output-display execution_count=647}\n```\nTrue\n```\n:::\n:::\n\n\n## Fractions\n\n- Much worse with fractions I find.\n\n::: {#eff89e57 .cell execution_count=3}\n``` {.python .cell-code}\n1 / 7000000 * 7000000\n```\n\n::: {.cell-output .cell-output-display execution_count=648}\n```\n0.9999999999999999\n```\n:::\n:::\n\n\n## Floats:\n\n- The IEEE 754 Floating-Point Standard\n\n\n<img style=\"filter:invert(1)\" src=\"https://upload.wikimedia.org/wikipedia/commons/d/d2/Float_example.svg\">\n\n- It is basically scientific notation that fits in a fixed amount of characters.\n\n## What is it?\n\n- The IEEE 754 standard defines formats for representing floating-point numbers.\n- It specifies how floating-point numbers are stored and operated on in computer hardware.\n- Most modern CPUs adhere to this standard.\n\n::: {#65970b3a .cell execution_count=4}\n``` {.python .cell-code}\nimport sys\n# Check the floating-point precision on your system\nsys.float_info\n```\n\n::: {.cell-output .cell-output-display execution_count=649}\n```\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n```\n:::\n:::\n\n\n## Why is it important?\n\n- Ensures portability and consistency of numerical computations across different systems.\n- Without a standard, the same calculation could yield different results on different machines.\n- Essential for reliable scientific and engineering software.\n\n## Single Precision (Float32)\n\n- Uses 32 bits to represent a number.\n- 1 sign bit, 8 exponent bits, 23 significand (mantissa) bits.\n- Offers approximately 7 decimal digits of precision.\n\n::: {#f368c91c .cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nnp.float32(1/7)\n```\n\n::: {.cell-output .cell-output-display execution_count=650}\n```\n0.14285715\n```\n:::\n:::\n\n\n## Double Precision (Float64)\n\n- Uses 64 bits to represent a number.\n- 1 sign bit, 11 exponent bits, 52 significand bits.\n- Offers approximately 15-17 decimal digits of precision. This is the default in Python and NumPy.\n\n::: {#dc180d18 .cell execution_count=6}\n``` {.python .cell-code}\n# Example of a float64 number (default in Python)\n1/7\n```\n\n::: {.cell-output .cell-output-display execution_count=651}\n```\n0.14285714285714285\n```\n:::\n:::\n\n\n## Special Values\n\n- **Infinity $\\infty$**: Result of overflow or division by zero.\n\n::: {#940b18e0 .cell execution_count=7}\n``` {.python .cell-code}\nlil = np.finfo(np.float64).resolution # smallest recognizable value\nbig = np.finfo(np.float64).max # biggest recognizable value\nbig / lil\n```\n\n::: {.cell-output .cell-output-display execution_count=652}\n```\ninf\n```\n:::\n:::\n\n\n- **Not a Number (NaN)**: Result of undefined operations (e.g., $0/0$, $\\sqrt{-1}$).\n\n::: {#49297549 .cell execution_count=8}\n``` {.python .cell-code}\nnp.sqrt(-1)\n```\n\n::: {.cell-output .cell-output-display execution_count=653}\n```\nnan\n```\n:::\n:::\n\n\n## Pitfall 1: Limited Precision\n\n- Not all real numbers can be represented exactly.\n- Decimal numbers like 0.1 often have an infinitely repeating binary representation.\n- This leads to small, unavoidable rounding errors.\n\n::: {#8e86d7ea .cell execution_count=9}\n``` {.python .cell-code}\n.1 + .2\n```\n\n::: {.cell-output .cell-output-display execution_count=654}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n## Pitfall 2: Accumulation\n\n- Small rounding errors can accumulate over many operations.\n- This can lead to significant inaccuracies in long computations or iterative algorithms.\n- Careful algorithm design and error analysis are crucial.\n\n::: {#acb8355e .cell execution_count=10}\n``` {.python .cell-code}\ntotal = 0.0\nfor _ in range(100000):\n    total += 0.1\ntotal, 100000 * 0.1\n```\n\n::: {.cell-output .cell-output-display execution_count=655}\n```\n(10000.000000018848, 10000.0)\n```\n:::\n:::\n\n\n## Pitfall 3: Comparison Issues\n\n- Due to limited precision, direct equality comparisons (`==`) between floating-point numbers are often unreliable.\n\n::: {#cdb708e2 .cell execution_count=11}\n``` {.python .cell-code}\n(1 + 2) / 10\n```\n\n::: {.cell-output .cell-output-display execution_count=656}\n```\n0.3\n```\n:::\n:::\n\n\n::: {#bb6ac864 .cell execution_count=12}\n``` {.python .cell-code}\n1 / 10 + 2 / 10\n```\n\n::: {.cell-output .cell-output-display execution_count=657}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n## Pitfall 4: Subtractive Cancellation\n\n- Occurs when subtracting two nearly equal numbers.\n- The most significant bits cancel out, leaving only the less significant bits.\n- Can drastically reduce the effective precision.\n\n::: {#24ab0679 .cell execution_count=13}\n``` {.python .cell-code}\nx = 1.0000000000000001\ny = 1.0000000000000000\nx - y\n```\n\n::: {.cell-output .cell-output-display execution_count=658}\n```\n0.0\n```\n:::\n:::\n\n\n# Symbolic Computation\n\n## Credit\n\n- The [SymPy tutorial](https://docs.sympy.org/latest/tutorials/intro-tutorial/).\n- SymPy solves the floating point problem.\n\n## Quoth SymPy\n\n> Symbolic computation deals with the computation of mathematical objects symbolically. This means that the mathematical objects are represented exactly, not approximately, and mathematical expressions with unevaluated variables are left in symbolic form.\n\n## Non-symbolic Computation\n\n- A common problem in computing is to compute the likes of distance between points separated by vectors.\n- Imagine two objects are separated by a horizontal displacement of `3` units, and vertical displacement of `4` units, and we wish to determine the minimum distance.\n- A straightforward application of the Pythagorean Theorem.\n\n::: {#140a329c .cell execution_count=14}\n``` {.python .cell-code}\nnp.sqrt(3 * 3 + 4 * 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=659}\n```\n5.0\n```\n:::\n:::\n\n\n## Pitfalls\n\n- These distances quickly become inaccurate.\n\n::: {#1c733d1d .cell execution_count=15}\n``` {.python .cell-code}\nnp.sqrt(2 * 2 + 4 * 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=660}\n```\n4.47213595499958\n```\n:::\n:::\n\n\n- Then stuff like [this](https://www.kezi.com/railroad-bridge-collapses-into-marys-river-in-corvallis/article_50b3ab98-cae2-11ef-86a9-2b8ecb0cf78c.html) happens:\n![](bridge.jpg)\n\n## Symbolic Computation\n\n- In point of fact, the solution to $\\sqrt{2^2 + 4*2}$ is actually $\\sqrt{20}$ and there's no other graceful way to represent it.\n- So we'll use *symbols* to store values.\n\n::: {#2f3f0c7b .cell execution_count=16}\n``` {.python .cell-code}\nimport sympy\nx = sympy.symbols('x')\ny = sympy.symbols('y')\ndist = sympy.sqrt(x + y)\ndist\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=661}\n$\\displaystyle \\sqrt{x + y}$\n:::\n:::\n\n\n## Expressions\n\n- We term this a \"symbolic expression\".\n- We can perform operations...\n\n::: {#8578c372 .cell execution_count=17}\n``` {.python .cell-code}\n2 * dist\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=662}\n$\\displaystyle 2 \\sqrt{x + y}$\n:::\n:::\n\n\n- We can add other symbols...\n\n::: {#431077c0 .cell execution_count=18}\n``` {.python .cell-code}\nz = sympy.symbols('z')\nz + dist\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=663}\n$\\displaystyle z + \\sqrt{x + y}$\n:::\n:::\n\n\n## Niceties\n\n- We can declare multiple symbols at once:\n\n::: {#24a9a280 .cell execution_count=19}\n``` {.python .cell-code}\na, b, c = sympy.symbols('a b c')\n```\n:::\n\n\n- SymPy will automatically simplify.\n\n::: {#ad0014ee .cell execution_count=20}\n``` {.python .cell-code}\nsympy.sqrt(20)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=665}\n$\\displaystyle 2 \\sqrt{5}$\n:::\n:::\n\n\n- Compare:\n\n::: {#7979cd33 .cell execution_count=21}\n``` {.python .cell-code}\nnp.sqrt(20), np.sqrt(5), 2 * np.sqrt(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=666}\n```\n(4.47213595499958, 2.23606797749979, 4.47213595499958)\n```\n:::\n:::\n\n\n# Operations \n\n## Extended Floats\n\n- SymPy uses floats by default, but doesn't have to.\n- You can specify a number of decimals for any value.\n- We also should that SymPy contains some useful constants!\n\n::: {#8e908c13 .cell execution_count=22}\n``` {.python .cell-code}\n# \"Evaluate as float to 100 digits\"\n# We use sympy.py, not e.g. np.pi\nsympy.pi.evalf(100)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=667}\n$\\displaystyle 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068$\n:::\n:::\n\n\n## Substitution\n\n- Often we want to solve an equation algebraically and *also* know a numerical solution.\n- The usefulness of SymPy is to do both, and maximally simply the result to minimize error.\n- We can use `subs()` to get solutions given values.\n\n::: {#a9880dc5 .cell execution_count=23}\n``` {.python .cell-code}\ndist\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=668}\n$\\displaystyle \\sqrt{x + y}$\n:::\n:::\n\n\n## Value Substitution\n- Substitute `3` for `x`\n\n::: {#e33bb024 .cell execution_count=24}\n``` {.python .cell-code}\ndist.subs(x, 3)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=669}\n$\\displaystyle \\sqrt{y + 3}$\n:::\n:::\n\n\n## Expression Substitution\n\n- Perhaps `y` is, itself, a distance expressed over a right triangle with sides `a` and `b`\n\n::: {#1f26b26f .cell execution_count=25}\n``` {.python .cell-code}\ndist.subs(y,a*a+b*b)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=670}\n$\\displaystyle \\sqrt{a^{2} + b^{2} + x}$\n:::\n:::\n\n\n## Strings\n\n- Sometimes we want to take a Python expression and convert to a symbolic SymPy expression.\n\n::: {#69f2d603 .cell execution_count=26}\n``` {.python .cell-code}\nstr_expr = \"x**2 + 3*x - 1/2\"\nfrom sympy import sympify\nexpr = sympify(str_expr)\nexpr\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=671}\n$\\displaystyle x^{2} + 3 x - \\frac{1}{2}$\n:::\n:::\n\n\n- Then calculate with `.subs()`\n\n::: {#a7c1a3a4 .cell execution_count=27}\n``` {.python .cell-code}\nexpr.subs(x, 2)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=672}\n$\\displaystyle \\frac{19}{2}$\n:::\n:::\n\n\n## Functions\n\n- Sibling of `vectorize`\n- Takes a SymPy expression, makes a Python function.\n\n::: {#ae53a36d .cell execution_count=28}\n``` {.python .cell-code}\nexpr # so we remember.\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=673}\n$\\displaystyle x^{2} + 3 x - \\frac{1}{2}$\n:::\n:::\n\n\n- Calculate...\n\n::: {#baa6a98d .cell execution_count=29}\n``` {.python .cell-code}\nf = sympy.lambdify(x, expr, \"scipy\")\nf(np.arange(10))\n```\n\n::: {.cell-output .cell-output-display execution_count=674}\n```\narray([ -0.5,   3.5,   9.5,  17.5,  27.5,  39.5,  53.5,  69.5,  87.5,\n       107.5])\n```\n:::\n:::\n\n\n## Aside: SciPy/NumPy\n\n- **Always** use `lambdify` specified with `\"scipy\"` (or `\"numpy\"`) if you have SciPy or even just NumPy installed\n- It uses NumPy's more powerful (than Python's) mathematical operations.\n\n## Aside: Plots\n\n::: {#da7bba59 .cell execution_count=30}\n``` {.python .cell-code}\n# import sympy\n# from sympy.abc import x\n# import scipy\nimport matplotlib.pyplot as plt\nf = sympy.lambdify(x,x*x,\"scipy\")\nxs = np.linspace(-5,5) \nplt.plot(xs, f(xs))\n```\n\n::: {.cell-output .cell-output-display}\n![](08_sympy_files/figure-revealjs/cell-30-output-1.png){width=790 height=411}\n:::\n:::\n\n\n## Simplification\n\n- If I use SymPy, I don't have to remember this:\n\n::: {#c392395e .cell execution_count=31}\n``` {.python .cell-code}\nsympy.simplify(sympy.sin(x)**2 + sympy.cos(x)**2)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=676}\n$\\displaystyle 1$\n:::\n:::\n\n\n- Or figure out this:\n\n::: {#087b6b63 .cell execution_count=32}\n``` {.python .cell-code}\nsympy.simplify((x**3 + x**2 - x - 1)/(x**2 + 2*x + 1))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=677}\n$\\displaystyle x - 1$\n:::\n:::\n\n\n## Polynomials\n\n- Often we *don't* want a simplified polynomial.\n\n::: {#578fa121 .cell execution_count=33}\n``` {.python .cell-code}\nsympy.simplify(x**2 + 2*x + 1)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=678}\n$\\displaystyle x^{2} + 2 x + 1$\n:::\n:::\n\n\n- We perhaps instead wish to `factor()`\n\n::: {#5b28728a .cell execution_count=34}\n``` {.python .cell-code}\nsympy.factor(x**2 + 2*x + 1)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=679}\n$\\displaystyle \\left(x + 1\\right)^{2}$\n:::\n:::\n\n\n## Expand\n\n- We may also start with factored form.\n\n::: {#e67c16cc .cell execution_count=35}\n``` {.python .cell-code}\neq = x**2 - (x+1) * (x-1)\n```\n:::\n\n\n- This can deceptively by made smaller by expanding it.\n\n::: {#ca96de0a .cell execution_count=36}\n``` {.python .cell-code}\nsympy.expand(eq)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=681}\n$\\displaystyle 1$\n:::\n:::\n\n\n## Fractions\n\n- We can also cancel out fractions.\n\n::: {#92814d86 .cell execution_count=37}\n``` {.python .cell-code}\neq = (x**2 + 2*x + 1)/(x**2 + x)\neq\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=682}\n$\\displaystyle \\frac{x^{2} + 2 x + 1}{x^{2} + x}$\n:::\n:::\n\n\n- Using `sympy.factor()`\n\n::: {#4a442b06 .cell execution_count=38}\n``` {.python .cell-code}\nsympy.factor(eq)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=683}\n$\\displaystyle \\frac{x + 1}{x}$\n:::\n:::\n\n\n## Powers\n\n- SymPy can also perform some simplifications related to exponention.\n- Movie size in memory is frame size time frame rate times duration.\n\n::: {#9a9ee4b6 .cell execution_count=39}\n``` {.python .cell-code}\neq = x**10*x**9*x**5*x*9 # Avatar in HD is ~4 hrs long at ~60fps\neq\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=684}\n$\\displaystyle 9 x^{25}$\n:::\n:::\n\n\n- Or just sub in `2`\n\n::: {#c01870de .cell execution_count=40}\n``` {.python .cell-code}\neq.subs(x,2)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=685}\n$\\displaystyle 301989888$\n:::\n:::\n\n\n# Calculus\n\n## Derivatives\n\n- We can calculate derivatives.\n\n::: {#79276684 .cell execution_count=41}\n``` {.python .cell-code}\nsympy.diff(x*x, x)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=686}\n$\\displaystyle 2 x$\n:::\n:::\n\n\n## Integrals\n\n::: {#bc9374b6 .cell execution_count=42}\n``` {.python .cell-code}\nsympy.integrate(sympy.sin(x), x)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=687}\n$\\displaystyle - \\cos{\\left(x \\right)}$\n:::\n:::\n\n\n## Evaluate Integrals\n\n- Give a variable a domain...\n\n::: {#f6043d4c .cell execution_count=43}\n``` {.python .cell-code}\nsympy.integrate(sympy.exp(x), (x, 0, 1))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=688}\n$\\displaystyle -1 + e$\n:::\n:::\n\n\n## Limits\n\n- One famous problem is to compute the value of the following function as it approaches zero:\n$$\n\\lim_{x\\to 0} \\frac{\\sin{x}}{x}\n$$\n\n## Evaluate limits\n\n::: {#4bd26206 .cell execution_count=44}\n``` {.python .cell-code}\neq = sympy.sin(x)/x\neq\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=689}\n$\\displaystyle \\frac{\\sin{\\left(x \\right)}}{x}$\n:::\n:::\n\n\n- We provide a variable and the value it approaches.\n\n::: {#d0b97593 .cell execution_count=45}\n``` {.python .cell-code}\nsympy.limit(eq, x, 0)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=690}\n$\\displaystyle 1$\n:::\n:::\n\n\n## Viewing limits\n\n- To create a printable limit object that can be evaluated.\n\t- Capitalize\n\t- Resolve via `.doit`\n\t- Also works for `Derivative` and `Integral`\n\n::: {#cb1aabb7 .cell execution_count=46}\n``` {.python .cell-code}\nlm = sympy.Limit(eq, x, 0)\nlm, lm.doit()\n```\n\n::: {.cell-output .cell-output-display execution_count=691}\n```\n(Limit(sin(x)/x, x, 0, dir='+'), 1)\n```\n:::\n:::\n\n\n# Solutions\n\n## Solve Equations\n\n> [The Python package SymPy can symbolically solve equations, differential equations, linear equations, nonlinear equations, matrix problems, inequalities, Diophantine equations, and evaluate integrals. SymPy can also solve numerically.](https://docs.sympy.org/latest/guides/solving/index.html)\n\n\n## Algebra\n\n- We use the much nicer way to get variable names.\n\n::: {#30bace38 .cell execution_count=47}\n``` {.python .cell-code}\nfrom sympy.abc import x, y\n```\n:::\n\n\n- We will aim to solve the following:\n$$\nx^2 = y\n$$\n\n## Write in SymPy\n\n- SymPy, like many algebra systems, expects equations to be expressed as equal to zero.\n- We note the following equivalence.\n$$\nx^2 = y \\equiv x^2 - y = 0\n$$\n- So we write:\n\n::: {#3eaa496f .cell execution_count=48}\n``` {.python .cell-code}\neq = x*x - y\n```\n:::\n\n\n## Solve\n\n- To solve, we simply use `sympy.solve()`\n\t- We specify the equation to solve, and\n\t- The variable for which to solve.\n\n::: {#65a357aa .cell execution_count=49}\n``` {.python .cell-code}\nsympy.solve(eq, x)\n```\n\n::: {.cell-output .cell-output-display execution_count=694}\n```\n[-sqrt(y), sqrt(y)]\n```\n:::\n:::\n\n\n- We could also do:\n\n::: {#6ca67625 .cell execution_count=50}\n``` {.python .cell-code}\nsympy.solve(eq, y)\n```\n\n::: {.cell-output .cell-output-display execution_count=695}\n```\n[x**2]\n```\n:::\n:::\n\n\n## `==` and `Eq()`\n\n- SymPy, for a variety of good reasons, struggles with `==` in equations, so use `Eq()`\n\n::: {#171cb281 .cell execution_count=51}\n``` {.python .cell-code}\neq = sympy.Eq(x*x,y)\neq\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=696}\n$\\displaystyle x^{2} = y$\n:::\n:::\n\n\n- It works as expected.\n\n::: {#e9fab676 .cell execution_count=52}\n``` {.python .cell-code}\nsympy.solve(eq)\n```\n\n::: {.cell-output .cell-output-display execution_count=697}\n```\n[{y: x**2}]\n```\n:::\n:::\n\n\n## Aside: Rationals\n\n- The is true for fractions with `Rational()`\n\n::: {#35106b55 .cell execution_count=53}\n``` {.python .cell-code}\nsympy.Rational(5/2)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=698}\n$\\displaystyle \\frac{5}{2}$\n:::\n:::\n\n\n- In general, if something would be \"weird\" with Sympy, there is a capitalized name that does what you would expect.\n- Just check the documentation.\n\n# ODEs\n\n## Ordinary Differential Equations\n\n>  A differential equation is an equation that relates one or more unknown functions and their derivatives.\n\n> An ordinary differential equation (ODE) is a differential equation (DE) dependent on only a single independent variable.\n\n## Credit\n\n- [\"Numerical integration of Ordinary Differential Equations\"](https://www.sympy.org/scipy-2017-codegen-tutorial/notebooks/20-ordinary-differential-equations.html)\n\n## Equation\n\n- Consider the decay of tritium as an example.\n\n",
    "supporting": [
      "08_sympy_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}