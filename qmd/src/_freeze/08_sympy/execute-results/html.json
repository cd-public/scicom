{
  "hash": "06316e48c138819104f849c64c476bfc",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: SymPy\n---\n\n\n\n\n\n\n# Why SciPy?\n\n## What is SymPy?\n\n> [A Python library for symbolic mathematics. It aims to become a full-featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible. SymPy is written entirely in Python.](https://www.sympy.org/en/index.html)\n\n* **Sym**bolic **Py**thon\n\n## Why SymPy \n\n* \"SymPy is free both as in speech and as in beer.\"\n* \"Most computer algebra systems invent their own language. Not SymPy.\"\n* \"An advantage of SymPy is that it is lightweight.\"\n\n## Why not SymPy\n\n- To my knowledge, there's no real competitors with SymPy.\n- The closest are probably SageMath and Mathematica.\n- I use browser-based Mathematica via [https://www.wolframalpha.com/](https://www.wolframalpha.com/) from time to time (when I don't have a Python installation handy).\n\n## Cite\n\n```{.bibtex}\n@article{10.7717/peerj-cs.103,\n     title = {SymPy: symbolic computing in Python},\n     author = {Meurer, Aaron and Smith, Christopher P. and Paprocki, Mateusz and \\v{C}ert\\'{i}k, Ond\\v{r}ej and Kirpichev, Sergey B. and Rocklin, Matthew and Kumar, AMiT and Ivanov, Sergiu and Moore, Jason K. and Singh, Sartaj and Rathnayake, Thilina and Vig, Sean and Granger, Brian E. and Muller, Richard P. and Bonazzi, Francesco and Gupta, Harsh and Vats, Shivam and Johansson, Fredrik and Pedregosa, Fabian and Curry, Matthew J. and Terrel, Andy R. and Rou\\v{c}ka, \\v{S}t\\v{e}p\\'{a}n and Saboo, Ashutosh and Fernando, Isuru and Kulal, Sumith and Cimrman, Robert and Scopatz, Anthony},\n     year = 2017,\n     month = jan,\n     keywords = {Python, Computer algebra system, Symbolics},\n     abstract = {\n                SymPy is an open source computer algebra system written in pure Python. It is built with a focus on extensibility and ease of use, through both interactive and programmatic applications. These characteristics have led SymPy to become a popular symbolic library for the scientific Python ecosystem. This paper presents the architecture of SymPy, a description of its features, and a discussion of select submodules. The supplementary material provide additional examples and further outline details of the architecture and features of SymPy.\n             },\n     volume = 3,\n     pages = {e103},\n     journal = {PeerJ Computer Science},\n     issn = {2376-5992},\n     url = {https://doi.org/10.7717/peerj-cs.103},\n     doi = {10.7717/peerj-cs.103}\n    }\n```\n\n\n## pip again\n\n- Just like NumPy, Matplotlib is a Python package which we install via `pip`\n```{.bash code-line-numbers=\"false\"}\npython3 -m pip install sympy\n```\n- That might take a moment, when it does we can check it worked!\n\n# Motivation \n\n## Example\n\n- Computers don't hold numbers that precisely.\n\n::: {#e7a9edec .cell execution_count=2}\n``` {.python .cell-code}\n10.0 ** 100 == 10.0 ** 100 + 47\n```\n\n::: {.cell-output .cell-output-display execution_count=486}\n```\nTrue\n```\n:::\n:::\n\n\n## Fractions\n\n- Much worse with fractions I find.\n\n::: {#c830a23a .cell execution_count=3}\n``` {.python .cell-code}\n1 / 7000000 * 7000000\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=487}\n$\\displaystyle 1.0$\n:::\n:::\n\n\n## Floats:\n\n- The IEEE 754 Floating-Point Standard\n\n\n<img style=\"filter:invert(1)\" src=\"https://upload.wikimedia.org/wikipedia/commons/d/d2/Float_example.svg\">\n\n- It is basically scientific notation that fits in a fixed amount of characters.\n\n## What is it?\n\n- The IEEE 754 standard defines formats for representing floating-point numbers.\n- It specifies how floating-point numbers are stored and operated on in computer hardware.\n- Most modern CPUs adhere to this standard.\n\n::: {#5e6f966e .cell execution_count=4}\n``` {.python .cell-code}\nimport sys\n# Check the floating-point precision on your system\nsys.float_info\n```\n\n::: {.cell-output .cell-output-display execution_count=488}\n```\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n```\n:::\n:::\n\n\n## Why is it important?\n\n- Ensures portability and consistency of numerical computations across different systems.\n- Without a standard, the same calculation could yield different results on different machines.\n- Essential for reliable scientific and engineering software.\n\n## Single Precision (Float32)\n\n- Uses 32 bits to represent a number.\n- 1 sign bit, 8 exponent bits, 23 significand (mantissa) bits.\n- Offers approximately 7 decimal digits of precision.\n\n::: {#36c60e86 .cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nnp.float32(1/7)\n```\n\n::: {.cell-output .cell-output-display execution_count=489}\n```\nnp.float32(0.14285715)\n```\n:::\n:::\n\n\n## Double Precision (Float64)\n\n- Uses 64 bits to represent a number.\n- 1 sign bit, 11 exponent bits, 52 significand bits.\n- Offers approximately 15-17 decimal digits of precision. This is the default in Python and NumPy.\n\n::: {#3166739b .cell execution_count=6}\n``` {.python .cell-code}\n# Example of a float64 number (default in Python)\n1/7\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=490}\n$\\displaystyle 0.142857142857143$\n:::\n:::\n\n\n## Special Values\n\n- **Infinity $\\infty$**: Result of overflow or division by zero.\n\n::: {#9a77ff74 .cell execution_count=7}\n``` {.python .cell-code}\nlil = np.finfo(np.float64).resolution # smallest recognizable value\nbig = np.finfo(np.float64).max # biggest recognizable value\nbig / lil\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\cd-desk\\AppData\\Local\\Temp\\ipykernel_21564\\563832135.py:3: RuntimeWarning:\n\noverflow encountered in scalar divide\n\n```\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=491}\n$\\displaystyle \\infty$\n:::\n:::\n\n\n- **Not a Number (NaN)**: Result of undefined operations (e.g., $0/0$, $\\sqrt{-1}$).\n\n::: {#568d17fb .cell execution_count=8}\n``` {.python .cell-code}\nnp.sqrt(-1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\cd-desk\\AppData\\Local\\Temp\\ipykernel_21564\\3438155168.py:1: RuntimeWarning:\n\ninvalid value encountered in sqrt\n\n```\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=492}\n$\\displaystyle \\text{NaN}$\n:::\n:::\n\n\n## Pitfall 1: Limited Precision\n\n- Not all real numbers can be represented exactly.\n- Decimal numbers like 0.1 often have an infinitely repeating binary representation.\n- This leads to small, unavoidable rounding errors.\n\n::: {#7d0e5b95 .cell execution_count=9}\n``` {.python .cell-code}\n.1 + .2\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=493}\n$\\displaystyle 0.3$\n:::\n:::\n\n\n## Pitfall 2: Accumulation\n\n- Small rounding errors can accumulate over many operations.\n- This can lead to significant inaccuracies in long computations or iterative algorithms.\n- Careful algorithm design and error analysis are crucial.\n\n::: {#36b95caa .cell execution_count=10}\n``` {.python .cell-code}\ntotal = 0.0\nfor _ in range(100000):\n    total += 0.1\ntotal, 100000 * 0.1\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=494}\n$\\displaystyle \\left( 10000.0000000188, \\  10000.0\\right)$\n:::\n:::\n\n\n## Pitfall 3: Comparison Issues\n\n- Due to limited precision, direct equality comparisons (`==`) between floating-point numbers are often unreliable.\n\n::: {#18bf1866 .cell execution_count=11}\n``` {.python .cell-code}\n(1 + 2) / 10\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=495}\n$\\displaystyle 0.3$\n:::\n:::\n\n\n::: {#d0774422 .cell execution_count=12}\n``` {.python .cell-code}\n1 / 10 + 2 / 10\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=496}\n$\\displaystyle 0.3$\n:::\n:::\n\n\n## Pitfall 4: Subtractive Cancellation\n\n- Occurs when subtracting two nearly equal numbers.\n- The most significant bits cancel out, leaving only the less significant bits.\n- Can drastically reduce the effective precision.\n\n::: {#71e70936 .cell execution_count=13}\n``` {.python .cell-code}\nx = 1.0000000000000001\ny = 1.0000000000000000\nx - y\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=497}\n$\\displaystyle 0.0$\n:::\n:::\n\n\n# Symbolic Computation\n\n## Credit\n\n- The [SymPy tutorial](https://docs.sympy.org/latest/tutorials/intro-tutorial/).\n- SymPy solves the floating point problem.\n\n## Quoth SymPy\n\n> Symbolic computation deals with the computation of mathematical objects symbolically. This means that the mathematical objects are represented exactly, not approximately, and mathematical expressions with unevaluated variables are left in symbolic form.\n\n## Non-symbolic Computation\n\n- A common problem in computing is to compute the likes of distance between points separated by vectors.\n- Imagine two objects are separated by a horizontal displacement of `3` units, and vertical displacement of `4` units, and we wish to determine the minimum distance.\n- A straightforward application of the Pythagorean Theorem.\n\n::: {#b33830f2 .cell execution_count=14}\n``` {.python .cell-code}\nnp.sqrt(3 * 3 + 4 * 4)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=498}\n$\\displaystyle 5.0$\n:::\n:::\n\n\n## Pitfalls\n\n- These distances quickly become inaccurate.\n\n::: {#a408693d .cell execution_count=15}\n``` {.python .cell-code}\nnp.sqrt(2 * 2 + 4 * 4)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=499}\n$\\displaystyle 4.47213595499958$\n:::\n:::\n\n\n- Then stuff like [this](https://www.kezi.com/railroad-bridge-collapses-into-marys-river-in-corvallis/article_50b3ab98-cae2-11ef-86a9-2b8ecb0cf78c.html) happens:\n![](bridge.jpg)\n\n## Symbolic Computation\n\n- In point of fact, the solution to $\\sqrt{2^2 + 4*2}$ is actually $\\sqrt{20}$ and there's no other graceful way to represent it.\n- So we'll use *symbols* to store values.\n\n::: {#581e3be4 .cell execution_count=16}\n``` {.python .cell-code}\nimport sympy\nx = sympy.symbols('x')\ny = sympy.symbols('y')\ndist = sympy.sqrt(x + y)\ndist\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=500}\n$\\displaystyle \\sqrt{x + y}$\n:::\n:::\n\n\n## Expressions\n\n- We term this a \"symbolic expression\".\n- We can perform operations...\n\n::: {#6303d527 .cell execution_count=17}\n``` {.python .cell-code}\n2 * dist\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=501}\n$\\displaystyle 2 \\sqrt{x + y}$\n:::\n:::\n\n\n- We can add other symbols...\n\n::: {#70a60f74 .cell execution_count=18}\n``` {.python .cell-code}\nz = sympy.symbols('z')\nz + dist\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=502}\n$\\displaystyle z + \\sqrt{x + y}$\n:::\n:::\n\n\n## Niceties\n\n- We can declare multiple symbols at once:\n\n::: {#63d14cb6 .cell execution_count=19}\n``` {.python .cell-code}\na, b, c = sympy.symbols('a b c')\n```\n:::\n\n\n- SymPy will automatically simplify.\n\n::: {#39a25bd4 .cell execution_count=20}\n``` {.python .cell-code}\nsympy.sqrt(20)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=504}\n$\\displaystyle 2 \\sqrt{5}$\n:::\n:::\n\n\n- Compare:\n\n::: {#3d86845b .cell execution_count=21}\n``` {.python .cell-code}\nnp.sqrt(20), np.sqrt(5), 2 * np.sqrt(5)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=505}\n$\\displaystyle \\left( 4.47213595499958, \\  2.23606797749979, \\  4.47213595499958\\right)$\n:::\n:::\n\n\n# Operations \n\n## Extended Floats\n\n- SymPy uses floats by default, but doesn't have to.\n- You can specify a number of decimals for any value.\n- We also should that SymPy contains some useful constants!\n\n::: {#f6537697 .cell execution_count=22}\n``` {.python .cell-code}\n# \"Evaluate as float to 100 digits\"\n# We use sympy.py, not e.g. np.pi\nsympy.pi.evalf(100)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=506}\n$\\displaystyle 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068$\n:::\n:::\n\n\n## Substitution\n\n- Often we want to solve an equation algebraically and *also* know a numerical solution.\n- The usefulness of SymPy is to do both, and maximally simply the result to minimize error.\n- We can use `subs()` to get solutions given values.\n\n::: {#046409e9 .cell execution_count=23}\n``` {.python .cell-code}\ndist\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=507}\n$\\displaystyle \\sqrt{x + y}$\n:::\n:::\n\n\n## Value Substitution\n- Substitute `3` for `x`\n\n::: {#f796abaa .cell execution_count=24}\n``` {.python .cell-code}\ndist.subs(x, 3)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=508}\n$\\displaystyle \\sqrt{y + 3}$\n:::\n:::\n\n\n## Expression Substitution\n\n- Perhaps `y` is, itself, a distance expressed over a right triangle with sides `a` and `b`\n\n::: {#7602c050 .cell execution_count=25}\n``` {.python .cell-code}\ndist.subs(y,a*a+b*b)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=509}\n$\\displaystyle \\sqrt{a^{2} + b^{2} + x}$\n:::\n:::\n\n\n## Strings\n\n- Sometimes we want to take a Python expression and convert to a symbolic SymPy expression.\n\n::: {#ebb0a6d8 .cell execution_count=26}\n``` {.python .cell-code}\nstr_expr = \"x**2 + 3*x - 1/2\"\nfrom sympy import sympify\nexpr = sympify(str_expr)\nexpr\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=510}\n$\\displaystyle x^{2} + 3 x - \\frac{1}{2}$\n:::\n:::\n\n\n- Then calculate with `.subs()`\n\n::: {#e0c0c36b .cell execution_count=27}\n``` {.python .cell-code}\nexpr.subs(x, 2)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=511}\n$\\displaystyle \\frac{19}{2}$\n:::\n:::\n\n\n## Functions\n\n- Sibling of `vectorize`\n- Takes a SymPy expression, makes a Python function.\n\n::: {#ff7ef848 .cell execution_count=28}\n``` {.python .cell-code}\nexpr # so we remember.\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=512}\n$\\displaystyle x^{2} + 3 x - \\frac{1}{2}$\n:::\n:::\n\n\n- Calculate...\n\n::: {#9139395a .cell execution_count=29}\n``` {.python .cell-code}\nf = sympy.lambdify(x, expr, \"scipy\")\nf(np.arange(10))\n```\n\n::: {.cell-output .cell-output-display execution_count=513}\n```\narray([ -0.5,   3.5,   9.5,  17.5,  27.5,  39.5,  53.5,  69.5,  87.5,\n       107.5])\n```\n:::\n:::\n\n\n## Aside: SciPy/NumPy\n\n- **Always** use `lambdify` specified with `\"scipy\"` (or `\"numpy\"`) if you have SciPy or even just NumPy installed\n- It uses NumPy's more powerful (than Python's) mathematical operations.\n\n## Aside: Plots\n\n::: {#a467ed63 .cell execution_count=30}\n``` {.python .cell-code}\n# import sympy\n# from sympy.abc import x\n# import scipy\nimport matplotlib.pyplot as plt\nf = sympy.lambdify(x,x*x,\"scipy\")\nxs = np.linspace(-5,5) \nplt.plot(xs, f(xs))\n```\n\n::: {.cell-output .cell-output-display}\n![](08_sympy_files/figure-html/cell-30-output-1.png){width=566 height=411}\n:::\n:::\n\n\n## Simplification\n\n- If I use SymPy, I don't have to remember this:\n\n::: {#1c84947e .cell execution_count=31}\n``` {.python .cell-code}\nsympy.simplify(sympy.sin(x)**2 + sympy.cos(x)**2)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=515}\n$\\displaystyle 1$\n:::\n:::\n\n\n- Or figure out this:\n\n::: {#7cd63d30 .cell execution_count=32}\n``` {.python .cell-code}\nsympy.simplify((x**3 + x**2 - x - 1)/(x**2 + 2*x + 1))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=516}\n$\\displaystyle x - 1$\n:::\n:::\n\n\n## Polynomials\n\n- Often we *don't* want a simplified polynomial.\n\n::: {#c13e7e95 .cell execution_count=33}\n``` {.python .cell-code}\nsympy.simplify(x**2 + 2*x + 1)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=517}\n$\\displaystyle x^{2} + 2 x + 1$\n:::\n:::\n\n\n- We perhaps instead wish to `factor()`\n\n::: {#b8bc8e06 .cell execution_count=34}\n``` {.python .cell-code}\nsympy.factor(x**2 + 2*x + 1)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=518}\n$\\displaystyle \\left(x + 1\\right)^{2}$\n:::\n:::\n\n\n## Expand\n\n- We may also start with factored form.\n\n::: {#88af2a44 .cell execution_count=35}\n``` {.python .cell-code}\neq = x**2 - (x+1) * (x-1)\n```\n:::\n\n\n- This can deceptively by made smaller by expanding it.\n\n::: {#55309de5 .cell execution_count=36}\n``` {.python .cell-code}\nsympy.expand(eq)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=520}\n$\\displaystyle 1$\n:::\n:::\n\n\n## Fractions\n\n- We can also cancel out fractions.\n\n::: {#5127f7a9 .cell execution_count=37}\n``` {.python .cell-code}\neq = (x**2 + 2*x + 1)/(x**2 + x)\neq\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=521}\n$\\displaystyle \\frac{x^{2} + 2 x + 1}{x^{2} + x}$\n:::\n:::\n\n\n- Using `sympy.factor()`\n\n::: {#e5b7a274 .cell execution_count=38}\n``` {.python .cell-code}\nsympy.factor(eq)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=522}\n$\\displaystyle \\frac{x + 1}{x}$\n:::\n:::\n\n\n## Powers\n\n- SymPy can also perform some simplifications related to exponention.\n- Movie size in memory is frame size time frame rate times duration.\n\n::: {#53721824 .cell execution_count=39}\n``` {.python .cell-code}\neq = x**10*x**9*x**5*x*9 # Avatar in HD is ~4 hrs long at ~60fps\neq\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=523}\n$\\displaystyle 9 x^{25}$\n:::\n:::\n\n\n- Or just sub in `2`\n\n::: {#8121bbf3 .cell execution_count=40}\n``` {.python .cell-code}\neq.subs(x,2)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=524}\n$\\displaystyle 301989888$\n:::\n:::\n\n\n# Calculus\n\n## Derivatives\n\n- We can calculate derivatives.\n\n::: {#7aa65c67 .cell execution_count=41}\n``` {.python .cell-code}\nsympy.diff(x*x, x)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=525}\n$\\displaystyle 2 x$\n:::\n:::\n\n\n## Integrals\n\n::: {#b57aa601 .cell execution_count=42}\n``` {.python .cell-code}\nsympy.integrate(sympy.sin(x), x)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=526}\n$\\displaystyle - \\cos{\\left(x \\right)}$\n:::\n:::\n\n\n## Evaluate Integrals\n\n- Give a variable a domain...\n\n::: {#0699486d .cell execution_count=43}\n``` {.python .cell-code}\nsympy.integrate(sympy.exp(x), (x, 0, 1))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=527}\n$\\displaystyle -1 + e$\n:::\n:::\n\n\n## Limits\n\n- One famous problem is to compute the value of the following function as it approaches zero:\n$$\n\\lim_{x\\to 0} \\frac{\\sin{x}}{x}\n$$\n\n## Evaluate limits\n\n::: {#459e8a80 .cell execution_count=44}\n``` {.python .cell-code}\neq = sympy.sin(x)/x\neq\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=528}\n$\\displaystyle \\frac{\\sin{\\left(x \\right)}}{x}$\n:::\n:::\n\n\n- We provide a variable and the value it approaches.\n\n::: {#4830aa17 .cell execution_count=45}\n``` {.python .cell-code}\nsympy.limit(eq, x, 0)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=529}\n$\\displaystyle 1$\n:::\n:::\n\n\n## Viewing limits\n\n- To create a printable limit object that can be evaluated.\n\t- Capitalize\n\t- Resolve via `.doit`\n\t- Also works for `Derivative` and `Integral`\n\n::: {#a64b1ec4 .cell execution_count=46}\n``` {.python .cell-code}\nlm = sympy.Limit(eq, x, 0)\nlm, lm.doit()\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=530}\n$\\displaystyle \\left( \\lim_{x \\to 0^+}\\left(\\frac{\\sin{\\left(x \\right)}}{x}\\right), \\  1\\right)$\n:::\n:::\n\n\n# Solutions\n\n## Solve Equations\n\n> [The Python package SymPy can symbolically solve equations, differential equations, linear equations, nonlinear equations, matrix problems, inequalities, Diophantine equations, and evaluate integrals. SymPy can also solve numerically.](https://docs.sympy.org/latest/guides/solving/index.html)\n\n\n## Algebra\n\n- We use the much nicer way to get variable names.\n\n::: {#5bcb5329 .cell execution_count=47}\n``` {.python .cell-code}\nfrom sympy.abc import x, y\n```\n:::\n\n\n- We will aim to solve the following:\n$$\nx^2 = y\n$$\n\n## Write in SymPy\n\n- SymPy, like many algebra systems, expects equations to be expressed as equal to zero.\n- We note the following equivalence.\n$$\nx^2 = y \\equiv x^2 - y = 0\n$$\n- So we write:\n\n::: {#28d4c25d .cell execution_count=48}\n``` {.python .cell-code}\neq = x*x - y\neq\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=532}\n$\\displaystyle x^{2} - y$\n:::\n:::\n\n\n## Solve\n\n- To solve, we simply use `sympy.solve()`\n\t- We specify the equation to solve, and\n\t- The variable for which to solve.\n\n::: {#5ff1e597 .cell execution_count=49}\n``` {.python .cell-code}\nsympy.solve(eq, x)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=533}\n$\\displaystyle \\left[ - \\sqrt{y}, \\  \\sqrt{y}\\right]$\n:::\n:::\n\n\n- We could also do:\n\n::: {#b9370e75 .cell execution_count=50}\n``` {.python .cell-code}\nsympy.solve(eq, y)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=534}\n$\\displaystyle \\left[ x^{2}\\right]$\n:::\n:::\n\n\n## `==` and `Eq()`\n\n- SymPy, for a variety of good reasons, struggles with `==` in equations, so use `Eq()`\n\n::: {#d327e358 .cell execution_count=51}\n``` {.python .cell-code}\neq = sympy.Eq(x*x,y)\neq\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=535}\n$\\displaystyle x^{2} = y$\n:::\n:::\n\n\n- It works as expected.\n\n::: {#9f2959d5 .cell execution_count=52}\n``` {.python .cell-code}\nsympy.solve(eq)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=536}\n$\\displaystyle \\left[ \\left\\{ y : x^{2}\\right\\}\\right]$\n:::\n:::\n\n\n## Aside: Rationals\n\n- The is true for fractions with `Rational()`\n\n::: {#5b8692c7 .cell execution_count=53}\n``` {.python .cell-code}\nsympy.Rational(5/2)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=537}\n$\\displaystyle \\frac{5}{2}$\n:::\n:::\n\n\n- In general, if something would be \"weird\" with Sympy, there is a capitalized name that does what you would expect.\n- Just check the documentation.\n\n# Printing\n\n## Pretty Print\n\n- SymPy provides a number of ways to see equations.\n- By default, these slides use \"LaTeX\", which I regard as the standard for mathematical typesetting.\n- However, it doesn't often show up that way in the terminal!\n\n## init_printing\n\n- Here's what my terminal looks like:\n\n```{.python code-line-numbers=\"false\"}\n>>> import sympy\n>>> from sympy.abc import x, y, z\n>>> sympy.Eq(x*x,y)\nEq(x**2, y)\n>>> sympy.init_printing()\n>>> sympy.Eq(x*x,y)\n 2\nx  = y\n```\n\n## Options\n\n- The following visualization methods are usably by SymPy:\n   -  str\n   -  srepr\n   -  ASCII pretty printer\n   -  Unicode pretty printer\n   -  LaTeX\n   -  MathML\n   -  Dot\n\n## Example\n\n- We'll use an integral example:\n\n::: {#6002d45a .cell execution_count=54}\n``` {.python .cell-code}\nsympy.Integral(sympy.sqrt(1/x), x)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=538}\n$\\displaystyle \\int \\sqrt{\\frac{1}{x}}\\, dx$\n:::\n:::\n\n\n## str\n\n- Just gives the string, basically as we typed it in.\n\n::: {#91aa4524 .cell execution_count=55}\n``` {.python .cell-code}\nstr(sympy.Integral(sympy.sqrt(1/x), x))\n```\n\n::: {.cell-output .cell-output-display execution_count=539}\n```\n'Integral(sqrt(1/x), x)'\n```\n:::\n:::\n\n\n## srepr\n\n- `srepr` is string *representation* and is more exact and verbose. \n- I don't use it often, but it can be helpful to examine equations when I get unexpected answers.\n\n::: {#7280bcff .cell execution_count=56}\n``` {.python .cell-code}\nsympy.srepr(sympy.Integral(sympy.sqrt(1/x), x))\n```\n\n::: {.cell-output .cell-output-display execution_count=540}\n```\n\"Integral(Pow(Pow(Symbol('x'), Integer(-1)), Rational(1, 2)), Tuple(Symbol('x')))\"\n```\n:::\n:::\n\n\n## ASCII\n\n- ASCII is the oldest major standard for character displays, with 127 characters including non-printing or whitespace characters like tab and space.\n- We can make \"ASCII art\" of equations via `pprint`.\n  \t- We must set `use_unicode` to `False`\n\n::: {#8585ccb4 .cell execution_count=57}\n``` {.python .cell-code}\nsympy.pprint(sympy.Integral(sympy.sqrt(1/x), x), use_unicode=False)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  /          \n |           \n |     ___   \n |    / 1    \n |   /  -  dx\n | \\/   x    \n |           \n/            \n```\n:::\n:::\n\n\n## Unicode\n\n- We get some slightly smoother lines with the more complete Unicode character set.\n\t- Unicode is the *modern* more complete character set including non-English characters and the likes of emojis. 🤔💭🔢✖️🧮\n\n::: {#470dfbd9 .cell execution_count=58}\n``` {.python .cell-code}\nsympy.pprint(sympy.Integral(sympy.sqrt(1/x), x), use_unicode=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n⌠           \n⎮     ___   \n⎮    ╱ 1    \n⎮   ╱  ─  dx\n⎮ ╲╱   x    \n⌡           \n```\n:::\n:::\n\n\n## LaTeX\n\n- My favorite (by far!)\n- I use LaTeX (.tex) a lot in these and other slides.\n\n::: {#f719e48e .cell execution_count=59}\n``` {.python .cell-code}\nsympy.latex(sympy.Integral(sympy.sqrt(1/x), x))\n```\n\n::: {.cell-output .cell-output-display execution_count=543}\n```\n'\\\\int \\\\sqrt{\\\\frac{1}{x}}\\\\, dx'\n```\n:::\n:::\n\n\n- I don't see the double backslash in my terminal, that is just an artiffact of the slides.\n\n```{.python code-line-numbers=\"false\"}\n>>> sympy.latex(sympy.Integral(sympy.sqrt(1/x), x))\n\\int \\sqrt{\\frac{1}{x}}\\, dxyy\n```\n\n## Using LaTeX\n\n- I can directly display that LaTeX in these slides...\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n- I type:\n\n```{.LaTeX code-line-numbers=\"false\" filename=\"file.tex\"}\n$$\n\\int \\sqrt{\\frac{1}{x}}\\, dxyy\n$$\n```\n\n- `$$` denotes LaTeX \"math mode\", versus just basic text editing.\n\n:::\n\n::: {.column width=\"50%\"}\n\n- We see:\n\n$$\n\\int \\sqrt{\\frac{1}{x}}\\, dxyy\n$$\n\n:::\n\n::::\n\n## QuickLaTeX\n\n- You can see examples online:\n- Go to [https://www.quicklatex.com/](https://www.quicklatex.com/)\n- Use this code:\n```{.LaTeX code-line-numbers=\"false\"}\n\\int \\sqrt{\\frac{1}{x}}\\, dxyy\n```\n- I see this:\n\n<center>\n<img style=\"background:white;width:30%\" src=\"qlx.png\"></img>\n</center>\n\n## Overleaf\n\n- The preferred way to use LaTeX for most students is Overleaf:\n  \t- [https://www.overleaf.com/](https://www.overleaf.com/)\n- I use it at the command line via `texlive`\n  \t- [https://www.tug.org/texlive/](https://www.tug.org/texlive/)\n\n## `tex` command\n\n- I write the LaTeX output to file. \n```{.python filename=\"integral.py\"}\nimport sympy \nx = sympy.symbols('x')\nprint(sympy.latex(sympy.Integral(sympy.sqrt(1/x), x)))\n```\n- And then:\n```{.bash code-line-numbers=\"false\"}\n$ python3 integral.py > file.tex\n```\n- Or all at once using `;` to separate lines\n```{.bash code-line-numbers=\"false\"}\n$ python3 -c \"import sympy; x = sympy.symbols('x'); print(sympy.latex(sympy.Integral(sympy.sqrt(1/x), x)))\" > file.tex\n```\n\n\n\n## `nvim` edits\n\n- I open the file with `nvim` and add lines specifying I want a document and that I want \"math mode\"\n- Before:\n```{.LaTeX code-line-numbers=\"false\"}\n\\int \\sqrt{\\frac{1}{x}}\\, dx\n```\n- After:\n```{.LaTeX code-line-numbers=\"false\"}\n\\begin{document}\n$$\n\\int \\sqrt{\\frac{1}{x}}\\, dx\n$$\n\\end{document}\n```\n\n## Render\n\n- Simply render to a `.pdf` via\n\n```{.bash code-line-numbers=\"false\"}\n$ pdflatex file.tex\n```\n\n- I have uploaded the file as well:\n\t- [src/file.pdf](file.pdf)\n\n\n# ODEs\n\n## Ordinary Differential Equations\n\n> [A differential equation is an equation that relates one or more unknown functions and their derivatives.](https://en.wikipedia.org/wiki/Differential_equation)\n\n> [An ordinary differential equation (ODE) is a differential equation (DE) dependent on only a single independent variable.](https://en.wikipedia.org/wiki/Ordinary_differential_equation)\n\n## Credit\n\n- [\"Numerical integration of Ordinary Differential Equations\"](https://www.sympy.org/scipy-2017-codegen-tutorial/notebooks/20-ordinary-differential-equations.html)\n\n## Equation\n\n- Consider the decay of tritium as an example.\n\n$$\n{}^3\\text{H} \\xrightarrow{\\lambda} {}^3\\text{He} + \\text{e}^- + \\bar{\\nu}_\\text{e}\n$$\n\n- This is, by the way, LaTeX:\n```{.LaTeX code-line-numbers=\"false\" filename=\"tritium.tex\"}\n{}^3\\text{H} \\xrightarrow{\\lambda} {}^3\\text{He} + \\text{e}^- + \\bar{\\nu}_\\text{e}\n```\n\n## [Tritium](https://www.cnsc-ccsn.gc.ca/eng/resources/fact-sheets/tritium/){.smaller}\n\n\n> Tritium is a radioactive isotope of hydrogen. It has the same number of protons and electrons as hydrogen but has 2 neutrons, whereas regular hydrogen does not have any. This makes tritium unstable and radioactive. Tritium is produced naturally from interactions of cosmic rays with gases in the upper atmosphere, and is also a by-product of nuclear reactors.\n\n\n## [Tritium](https://www.cnsc-ccsn.gc.ca/eng/resources/fact-sheets/tritium/){.smaller}\n\n> Like all radioactive isotopes, tritium decays. As it decays, it emits beta radiation.\n\n> The physical half-life of tritium is 12.33 years, meaning that it takes just over 12 years for tritium to decay to half of its original amount. As tritium decays, it changes to helium. \n\n\n## Derivatives\n\n- We denote the \"number density\" (number of atoms in a sample) of $^3\\text{H}$ as a function of time $y(t)$\n- The *rate of change* (derivate)\n\n$$\n\\frac{d}{d t} y{\\left(t \\right)} = - \\lambda y{\\left(t \\right)}\n$$\n\n- This is a differential equation because an equation is a function of its own derivative.\n\n## Exercise\n\n1. Specify this equation in SymPy\n2. Solve useing `sympy.dsolve()`\n\n## Tools\n\n- This is how I got lambda:\n\n::: {#f8ece8e3 .cell execution_count=60}\n``` {.python .cell-code}\nt, l = sympy.symbols('t lambda') # use \"l\" as \"lambda\" is a Python keyword\n```\n:::\n\n\n- This is $y(t)$\n\n::: {#4423f6fa .cell execution_count=61}\n``` {.python .cell-code}\ny = sympy.Function('y')(t) # use capital Function ala Rational, Integral\n```\n:::\n\n\n- Take derivatives as follows:\n\n::: {#ba77cfc8 .cell execution_count=62}\n``` {.python .cell-code}\nf = sympy.Function('f')(x)\nf.diff(x)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=546}\n$\\displaystyle \\frac{d}{d x} f{\\left(x \\right)}$\n:::\n:::\n\n\n## Solution\n\n- Write:\n\n::: {#51e496bc .cell execution_count=63}\n``` {.python .cell-code code-fold=\"true\"}\nt, l = sympy.symbols('t lambda')\ny = sympy.Function('y')(t)\ndydt = y.diff(t)\nexpr = sympy.Eq(dydt, -l*y)\nexpr\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=547}\n$\\displaystyle \\frac{d}{d t} y{\\left(t \\right)} = - \\lambda y{\\left(t \\right)}$\n:::\n:::\n\n\n- Solve:\n\n::: {#46ff33e0 .cell execution_count=64}\n``` {.python .cell-code code-fold=\"true\"}\nsympy.dsolve(expr)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=548}\n$\\displaystyle y{\\left(t \\right)} = C_{1} e^{- \\lambda t}$\n:::\n:::\n\n\n",
    "supporting": [
      "08_sympy_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}